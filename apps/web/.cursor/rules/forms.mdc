---
description: Instructions for handling forms
globs: 
alwaysApply: false
---
# Form Handling Standards

## Form Architecture

<form_structure>
1. Component Organization:
    - Feature-specific forms reside in `app/features/[feature]/components/`.
    - Follow the `[feature]-[purpose]-form.tsx` naming convention (e.g., `agent-form.tsx`, `user-form.tsx`).

2. Required Companion Files:
    - Schema definition and form options in `[feature].schema.ts`.
    - Server actions (API endpoints) in `[feature].api.ts`.
    - Tanstack Query query/mutation hooks in `[feature].query.ts`.
    - Business logic/database interactions in `[feature].service.ts`.
</form_structure>

## Validation & Schema

<validation_rules>
1. Zod Schema Definition:
   - Define the form data structure and validation rules using Zod in `[feature].schema.ts`.

   ```typescript
   // agent.schema.ts example
   import { Agents } from '@gingga/db/schema'
   import { z } from 'zod'

   // Schema specifically for the AgentForm component
   export const AgentFormSchema = z.object({
     name: z.string().min(1, 'Agent name is required.'),
     description: z.string().nullable(),
     instructions: z.string().min(1, 'Instructions are required.'),
     modelId: z.enum(Agents.modelId.enumValues).nullable().optional(),
     image: z.string().url({ message: 'Please enter a valid URL.' }).nullable(),
   })
   export type AgentFormValues = z.infer<typeof AgentFormSchema>
   ```

2. Tanstack Form Options:
   - Create a `formOptions` object using `formOptions` from `@tanstack/react-form`.
   - Define `defaultValues` matching the `AgentFormValues` type.
   - Set the `validators.onSubmit` property to the Zod schema for form-level validation upon submission.

   ```typescript
   // agent.schema.ts example
   import { formOptions } from '@tanstack/react-form'
   import { AgentFormSchema, AgentFormValues } from './agent.schema' // Assuming schema is in the same file

   export const agentFormOptions = formOptions({
     defaultValues: {
       name: '',
       description: null,
       instructions: '',
       modelId: null,
       image: null,
     } as AgentFormValues, // Cast or ensure type alignment
     validators: {
       onSubmit: AgentFormSchema,
     },
   })
   ```

3. Form Hook Initialization:
   - Use the custom `useAppForm` hook (likely defined in `@/components/form/tanstack-form`) in your form component.
   - Spread the predefined `formOptions`.
   - Provide `defaultValues` (potentially merging initial/edit values).
   - Define the `onSubmit` async function to handle form submission logic (e.g., calling a mutation).

   ```typescript
   // agent-form.tsx example
   import { useAppForm } from '~/components/form/tanstack-form'
   import { agentFormOptions, AgentFormSchema, AgentFormValues } from '../agent.schema'

   // Inside the component:
   const form = useAppForm({
     ...agentFormOptions, // Spread base options
     defaultValues: {
       ...agentFormOptions.defaultValues,
       ...initialValues, // Override with initial/edit values if provided
     },
     onSubmit: async ({ value }) => {
       await onSubmit(value) // Call the mutation or passed onSubmit handler
       // Optionally reset form: formApi.reset()
     },
     // Note: onSubmit validator is already in agentFormOptions
     // You can add field-level onChange validators here if needed
     // validators: {
     //   onChange: AgentFormSchema.shape.name // Example
     // }
   })
   ```

</validation_rules>

## Server Integration

<server_rules>
1. Tanstack Query Mutation Pattern:
   - Use `useMutation` from Tanstack Query to handle server state changes.
   - `mutationFn` should call the corresponding server action (e.g., `$createAgent`).
   - Use `onSuccess` to invalidate relevant queries and ensure data freshness.

   ```typescript
   // agent.query.ts example (Illustrative - Adapt based on actual hook)
   import { useMutation, useQueryClient } from '@tanstack/react-query'
   import { $createAgent } from './agent.api' // Import server action
   import { agentsQueryOptions } from './agent.query' // Assuming query options exist

   export const useCreateAgentMutation = () => {
     const queryClient = useQueryClient()
     return useMutation({
       mutationFn: $createAgent, // Server action reference
       onSuccess: async () => {
         // Invalidate queries that should refetch after creation
         await queryClient.invalidateQueries({ queryKey: agentsQueryOptions().queryKey })
       },
       // Add onError handling as needed
     })
   }
   ```

2. Server Action (`createServerFn`) Structure:
   - Define server actions using `createServerFn` from `@tanstack/react-start`.
   - Use the `POST` method for mutations.
   - Apply middleware (e.g., `authMiddleware`).
   - Integrate Zod validation using `zodValidator` with the appropriate schema (`AgentFormSchema`).
   - Implement the handler logic, calling service functions for database operations.
   - Include error handling (try/catch, `setResponseStatus`).

   ```typescript
   // agent.api.ts example
   import { createServerFn } from '@tanstack/react-start'
   import { zodValidator } from '@tanstack/zod-adapter'
   import { authMiddleware } from '~/middleware/auth-guard'
   import { AgentFormSchema } from './agent.schema'
   import { createAgent } from './agent.service'
   import { setResponseStatus } from '@tanstack/react-start/server'

   export const $createAgent = createServerFn({
       method: 'POST',
     })
     .middleware([authMiddleware])
     .validator(zodValidator(AgentFormSchema)) // Use form schema for validation
     .handler(async ({ data }) => {
       try {
         const agent = await createAgent(data) // Call service function
         return agent
       } catch (e) {
         console.error(e)
         setResponseStatus(500)
         // Consider returning a structured error
         return { error: 'Failed to create agent due to a server error.' }
       }
     })
   ```

</server_rules>

## UI Implementation

<ui_rules>
1. Tanstack Form Field Component (`form.AppField`):
   - Use the `form.AppField` component provided by `useAppForm` for each form input.
   - Specify the `name` prop corresponding to the schema key.
   - Optionally provide `validators.onChange` for field-level validation using the Zod schema's shape.
   - Use the render prop pattern (`children={(field) => ...}`) to access field state and handlers.

2. Field Structure (`FormFieldItem`, `FormFieldLabel`, etc.):
   - Inside `form.AppField`, use the components provided on the `field` object:
     - `field.FormFieldItem`: Wraps the entire field structure.
     - `field.FormFieldLabel`: Renders the `<label>`.
     - `field.FormFieldControl`: Wraps the actual input element.
     - `field.FormFieldMessage`: Displays validation errors (automatically linked).

3. Input Integration:
   - Bind standard input props (`name`, `value`, `onBlur`, `onChange`) to the `field` object's properties and methods:
     - `name={field.name}`
     - `value={field.state.value}`
     - `onBlur={field.handleBlur}`
     - `onChange={(e) => field.handleChange(e.target.value)}` (or directly `field.handleChange` for simple value updates)
   - Use `field.state.meta.errors` to check for errors and set `aria-invalid`.
   - Link errors to the message component using `aria-describedby` and `id`.

   ```tsx
   // agent-form.tsx <Input> example
   import { Input } from '@gingga/ui/components/input'

   // ... inside form component ...
   <form.AppField
     name="name"
     validators={{ // Optional: Field-level validation on change
       onChange: AgentFormSchema.shape.name,
     }}
     children={(field) => (
       <field.FormFieldItem>
         <field.FormFieldLabel>Agent Name</field.FormFieldLabel>
         <field.FormFieldControl>
           <Input
             name={field.name}
             value={field.state.value}
             onBlur={field.handleBlur}
             onChange={(e) => field.handleChange(e.target.value)}
             disabled={isSubmitting} // Use form state or prop
             placeholder="e.g., Customer Support Pro"
             aria-invalid={!!field.state.meta.errors.length}
             aria-describedby={
               field.state.meta.errors.length ? `${field.name}-errors` : undefined
             }
           />
         </field.FormFieldControl>
         {/* Error message automatically displayed based on field state */}
         <field.FormFieldMessage id={`${field.name}-errors`} />
       </field.FormFieldItem>
     )}
   />
   ```

4. Form Submission Button (`form.FormButton`):
   - Wrap the submit button within `form.AppForm` to access form state like `isSubmitting`.
   - Use `form.FormButton` for a button that automatically reflects the form's submission status.

   ```tsx
   // agent-form.tsx submit button example
   <form.AppForm>
     <form.FormButton variant="primary" size="xl" className="mt-10 w-full">
       {({ isSubmitting }) => (isSubmitting ? 'Saving...' : 'Save Agent')}
     </form.FormButton>
   </form.AppForm>
   ```

5. Triggering Submission:
   - Attach an `onSubmit` handler to the main `<form>` element.
   - Prevent default form submission and stop propagation.
   - Call `form.handleSubmit()` to trigger Tanstack Form's validation and `onSubmit` logic.

   ```tsx
   // agent-form.tsx form tag example
   <form
     onSubmit={(e) => {
       e.preventDefault()
       e.stopPropagation()
       void form.handleSubmit() // Trigger Tanstack Form submission
     }}
     {...formProps}
     className="space-y-4"
   >
     {/* Form fields go here */}
     {/* Submission button wrapped in form.AppForm */}
   </form>
   ```

</ui_rules>


